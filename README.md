# Programming Assignment Framework

## Introduction
This is a framework for developing Java programming assignment in an intuitive and fast way. Programming assignments consists of different artefacts, such as solution, start code, tests, descriptions etc. Currently, these are often manually developed in isolation from another, often with much information that is related or repeated. This is unnecessary time waste and also a breeding ground for causing inconsistencies and other bugs, especially when refactoring. The core idea for this framework is to centralize everything into one project and generating the different artefacts from that. This is done by writing the entire solution to the assignment first, and expanding it with annotations that are related to central concepts in programming assignments. Artefacts such as start code, solution without annotations, and descriptions are generated by running a Maven command.

## Installment

Copy this project to your computer either by cloning, forking or downloading this repository. This project relies on [Maven](https://maven.apache.org/download.cgi) so make sure you have it installed. Open the project and then a terminal and run the command `mvn clean install` to install the plugin into to your local maven repository. Make sure you run this command in the project's root directory, i.e., .../programmingAssignmentFramework. You may need to configure the JDK source and target version properties in the pom file to be compatible with your development environment. 


## Usage
Start by creating a new Maven project in your favorite Java IDE. Open up the pom.xml file in your new project and include the paf-annotations dependency to be able to use the different annotations in your project:

```xml
<dependency>
    <groupId>no.hvl</groupId>
    <artifactId>paf-annotations</artifactId>
    <version>1.0-SNAPSHOT</version>  
</dependency>
```

If this dependency is not found after reloading the pom file or project for some reason, then you can add the jar to the project as an external library. The jar is found in the `target` folder in the `paf-annotations` module in your local project of this framework. 

To be able to execute the plugin to generate the artefacts, you need to add a plugin to the Maven build lifecycle. This plugin has a configuration attribute where you define the path of the target folder to generate the artefacts in. An example of this is shown below:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>no.hvl</groupId>
            <artifactId>paf-maven-plugin</artifactId>
            <version>1.0-SNAPSHOT</version>
            <configuration>
                <targetPath>C:\Users\Acer\IntelliJProjects\HelloWorldOutput</targetPath>
            </configuration>
        </plugin>
    </plugins>
</build>
```

**Make sure your root folder for Java files is either called `src` or `source`**. To generate artefacts from your project run the command `mvn paf:generate` from the terminal. Make sure you are in the same directory as the pom file. This will not be as exciting if you have not used any of the annotations in your project.

### Annotations

**@Implement**

This is used as an annotation on constructs that should be implemented in an exercise. It can be used on classes/interfaces, field variables, constructors and methods. This annotation currently has three members (attributes):
* `int[] number`: This denotes the exercise number in which this construct should be implemented. The reason for this being an array of numbers is to be able to denote hierarchies in exercises. For example, exercise 1 might have two subexercises, which would be expressed with the arrays `{1,1}` and `{1,2}` respectively.
* `CopyOption transformOption`: This gives different options for what to do with the annotated construct when generating the start code. For constructs that contain bodies (methods and constructors), the solution can be wrapped between special statements which can be targeted by this copy option. The different options are:
    * `REMOVE_EVERYTHING`: Removes everything, both the skeleton and the body of the construct.
  * `REMOVE_BODY`: Removes then entire body, while the skeleton is kept. **NOT IMPLEMENTED PROPERLY YET**
  * `REPLACE_BODY`: Replaces the entire body with some other code that is specified by the `replacementId` attribute.
  * `REMOVE_SOLUTION`: Removes only the solution from the body, while everything outside the marked solution will be kept, including the skeleton. **NOT IMPLEMENTED PROPERLY YET**
  * `REPLACE_SOLUTION`: Replaces only the solution with some other code that is specified by the `replacementId` attribute.
    
* `String replacementId`: Specifies the id of the `ReplacementCode` annotation to use for replacing some code. This only need to be specified when the `transformOption` is set to `REPLACE_BODY` or `REPLACE_SOLUTION`.

**@ReplacementCode**

This is used to mark some construct whose body can be used as a replacement for some other construct that is annotated with `@Implement`. For example, all statements within a method body will be used in the replacement if it was annotated with `@ReplacementCode`.  This annotation only has one attribute: `String id` that must be specified. This id is what is referenced by the `replacementId` attribute in the `@Implement` annotation. 

**@Remove**

This annotation is used to remove constructs entirely from the generated start code. This may be useful in cases where you want to remove a solution, but the solution spans several methods. You probably also want to use this annotation in conjunction with the `@ReplacementCode` annotation as to not bloat the start code with unnecessary and confusing code for students. Using this annotation on a class or interface will remove the entire file from all the generated projects. 

### Marking Solutions

The markers used to capture solutions are technically annotations also. However, they are used somewhat different due to the restrictions on where it is allowed to insert annotations. The `SolutionStart` annotation is used to mark the start of a solution. This is done by inserting a variable declaration statement of type `SolutionStart` on the line before the solution. Note that is doesn't matter what you call the variable, just as long it is of type `SolutionStart`. **Do not include the annotation sign (@) prefix**. The same is done with `SolutionEnd` on the line after the solution to mark its end.

At some point you probably want to include a return statement in the solution. Unfortunately this will not compile, since the `SolutionEnd` statement will be unreachable. As a workaround, you can exclude the `SolutionEnd` statement, and the end of the method body will represent the end of the solution instead. Be careful with replacing solutions that has statements after it. If the replacement code end with a return or throw statement, then you will likely generate code that doesn't compile, due to the same unreachable statement problem explained above. Some examples of solution marking is shown below: 

Solution is completely wrapped:
```java
{
    ...
    SolutionStart s;
    str = "Hello World";
    SolutionEnd e;
    return str;
}
```

Solution with a return statement:
```java
{
    ...
    SolutionStart s;
    return "Hello World";
}
```

## Generated artefacts

So what is actually generated? There will be created two projects in the target path folder that was given in the configuration. One is called `startcode` and the other `solution`. Both projects will copy every file and folder from the source project (.git folder is ignored), while the Java files are modified according to the annotations. The pom file will also be modified to remove dependencies and plugins related to this framework (other dependencies and plugins will be kept). The `solution` project will keep all solutions, but remove all annotations and everything else that is related to this framework. The `startcode` project is similar, but the constructs annotated with `@Implement` are handled according to the `transformOption`.

The `startcode` project will also include a folder called `descriptions` that has a templated description file for each exercise. This is done with [AsciiDoc](https://asciidoc.org/) using attributes. These attributes make it possible to quickly refer to information about constructs that are marked with the `@Implement` annotation. This information includes the construct's simple name, full name, path, filename etc. This information is updated automatically when refactoring the construct, as long as it doesn't change its hierarchical position in the exercise. An example description is also included with each exercise. Both PDF and HTML can be generated from the AsciiDoc files. It is highly recommended installing an AsciiDoc plugin for your IDE to make it easier to work it:
* [IntelliJ AsciiDoc plugin](https://plugins.jetbrains.com/plugin/7391-asciidoc)
* [Eclipse AsciiDoc plugin](https://marketplace.eclipse.org/content/asciidoctor-editor)
* [VSCode AsciiDoc plugin](https://marketplace.visualstudio.com/items?itemName=asciidoctor.asciidoctor-vscode)


    
    




